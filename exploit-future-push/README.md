# Consensus Exploit Testing Guide

**Important Note:** The tools and descriptions in this document are for testing and validation purposes only. They demonstrate potential exploits that have been identified in security audits. The functionality of these miners has not yet been validated against a live network and should be used exclusively in controlled test environments.

## 2. Future-Push Attack Miner (`utils/miner.future-push.php`)

This miner is designed to test a "Future-Push" vulnerability, which is a specific type of "slip time" attack.

### Technical Details

The `miner.future-push.php` script demonstrates an attack where a miner can validate a block that was solved too quickly (and is therefore normally invalid). The script operates as follows:

1.  It begins mining, calculating a `hit` value for each attempt.
2.  In each attempt, it checks the `hit` against two values:
    -   The **current `target`**, based on the actual `elapsed` time.
    -   A **`future_target`**, calculated with a manipulated `elapsed` time (actual elapsed + slip time).
3.  The miner finds a block when the `hit` is greater than the `future_target`, even if it is still *less than* the current `target`.
4.  Once such a block is found, it immediately submits it with a future-dated timestamp.

This allows a miner to successfully submit a block that they did not technically have the hashrate to find, by exploiting the 30-second future timestamp allowance. The logic is encapsulated in a self-contained `FuturePushMiner` class within the script.

### How to Use

Run the miner from the command line. The node URL and your address are required. Other settings can be specified via command-line options or a `miner.conf` file in the same directory. Command-line options will always override settings from the config file.

**Basic Usage:**
```bash
php miner-push.php --node=<node_url> --address=<your_address> [options]
```

**Example with common options:**
```bash
# Run with 100% CPU, 6 threads, a 5-second report interval, and a 1-second slip time
php miner-push.php -c 100 -t 6 -i 5 -s 1
```
*(This example assumes `node` and `address` are set in `miner.conf`)*

**Options:**
-   `-n`, `--node=<url>`: The URL of the PHPCoin node to connect to. (Required)
-   `-a`, `--address=<addr>`: The PHPCoin address to mine rewards to. (Required)
-   `-c`, `--cpu=<percent>`: The percentage of CPU to use (0-100). Default: 50.
-   `-t`, `--threads=<num>`: The number of threads to use for mining. Default: 1.
-   `-i`, `--report-interval=<sec>`: The interval in seconds to report mining status. Default: 30.
-   `-s`, `--slip=<sec>`: The number of seconds to push the block's timestamp into the future. Default: 20.
-   `--flat-log`: Enable flat logging for environments that do not support carriage returns.

### Recommended Defense

A layered defense is the most effective way to prevent Future-Push and other "slip time" attacks.

1.  **Drastically Reduce the Future-Dating Window:** This is the most direct defense. Lower the maximum acceptable future timestamp from the current `time() + 30` to a much smaller value, such as `time() + 2`. This provides a small buffer for network latency and clock drift without being large enough to be gameable.
2.  **Implement Median Time Past (MTP):** As with the Timewarp attack, an MTP check will ensure that a block's timestamp is consistent with the recent history of the blockchain, preventing large deviations into the future.
3.  **Synchronize Clocks with NTP:** Nodes should use an NTP client to keep their local system time accurate, reducing the likelihood of network splits caused by clock drift.

---

## 3. Analysis of Exploit Advantage

This section provides a theoretical analysis of the advantage an attacker gains by executing these exploits, based on the following approximate **total network** statistics:
-   **Average Network Block Time:** ~65 seconds
-   **Average Network Hash Rate:** ~1600 H/s

### Timewarp Attack

The Timewarp attack is a **post-mining timing manipulation**. It does not provide any advantage in *finding* a valid hash. A miner must first find a genuinely valid block through normal, competitive mining.

Therefore, this attack **provides no advantage in solving a block**. Its sole purpose is to manipulate the `elapsed` time *after* a block has been solved to influence the difficulty calculation for future blocks.

### Future-Push Attack

The Future-Push attack provides a significant advantage by allowing an attacker to validate a block that would be considered invalid by honest miners.

The core of the Elapsed Proof of Work system is that the `target` (difficulty) is inversely proportional to the `elapsed` time since the last block. Honest miners must keep hashing until the `elapsed` time is high enough to lower the `target` below their `hit`. On average, this takes the entire network **~65 seconds**.

An attacker using the Future-Push exploit can find a block with a low `elapsed` time (e.g., 10 seconds) and a `hit` that is *too low* for the high `target`. By pushing the timestamp forward 29 seconds, they submit the block with an `elapsed` time of `10 + 29 = 39` seconds.

The advantage is clear:
-   An **honest miner** needs a `hit` that can beat a `target` calculated with an `elapsed` time of ~65 seconds.
-   An **attacker** only needs a `hit` that can beat a `target` calculated with an `elapsed` time of ~39 seconds.

Because the target is significantly easier to beat, the attacker can find a valid block much faster than an honest miner with the same hash power. This gives them a disproportionate share of the block rewards and allows them to find blocks more frequently than their raw hash power would otherwise permit.

---

## 4. Combining Exploits for Maximum Effect

The "Future-Push" and "Timewarp" attacks can be used in concert to create the most impactful exploit. This combined strategy allows a miner to not only find a block with a significant time advantage but also to maximally influence the difficulty of the next block.

The process is as follows:

1.  **Use the Future-Push Method:** A miner runs the `miner.future-push.php` script to find a block that is initially invalid but can be made valid by pushing the timestamp forward. This allows them to "solve" the block in a fraction of the normal time (e.g., 10 seconds).

2.  **Apply the Timewarp Principle:** Instead of broadcasting the block immediately, the miner waits for an additional period (e.g., 20-30 seconds).

3.  **Broadcast with a Future Timestamp:** After waiting, the miner broadcasts the block with its timestamp set far into the future (e.g., `time() + 29s`).

The result is a massively inflated `elapsed` time. For example, if a block is found in 10 seconds, the miner waits 25 seconds, and then pushes the timestamp 29 seconds into the future, the `elapsed` time for a block that only took 10 seconds to mine will be recorded as `10 + 25 + 29 = 64` seconds. This makes the invalid block appear as a normally mined block, which completely breaks the difficulty adjustment mechanism for the next block.
---

## 5. Algorithm Pseudocode

The core logic of the Future-Push miner is contained within its main hashing loop. The following pseudocode outlines the step-by-step process for finding and validating a block using the exploit.

```
// Main Hashing Loop
WHILE new_block has not been found on network:

  // 1. Calculate current time difference
  current_elapsed = time() - last_block_date

  // 2. Calculate targets
  real_target = (difficulty * 60) / current_elapsed
  future_target = (difficulty * 60) / (current_elapsed + slip)

  // 3. Generate hashes for this attempt
  argon_hash = calculate_argon("...", current_elapsed)
  nonce = calculate_nonce("...", argon_hash)

  // 4. Calculate hit value based on this attempt's hashes
  hit = calculate_hit(nonce, "...")

  // 5. Check for solution against the easier, future target
  IF hit > future_target THEN

    // A. A potential block is found. Now, recalculate hashes for the future time.
    solution_elapsed = current_elapsed + slip
    solution_date = last_block_date + solution_elapsed

    // B. Recalculate Argon and Nonce using the slipped time
    solution_argon = calculate_argon("...", solution_elapsed)
    solution_nonce = calculate_nonce("...", solution_argon)

    // C. CRITICAL: Recalculate the final HIT value using the new hashes.
    //    This is required for the node to accept the block.
    final_hit = calculate_hit(solution_nonce, "...")

    // D. Prepare and submit the block to the node
    SUBMIT {
      argon: solution_argon,
      nonce: solution_nonce,
      date: solution_date,
      elapsed: solution_elapsed,
      hit: final_hit
    }

    // E. Exit loop and wait for next block
    BREAK LOOP

  END IF

END WHILE
```
