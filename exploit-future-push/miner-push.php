<?php
/**
 * PHPCoin Self-Contained Miner
 *
 * This script is a standalone miner for the PHPCoin cryptocurrency. It is designed to be run from the command line
 * and does not require any external dependencies other than the standard PHP extensions.
 *
 * Usage:
 * php miner.self.php -n <node_url> -a <your_address> [options]
 * php miner.self.php --node=<node_url> --address=<your_address> [options]
 *
 * Configuration:
 * A `miner.conf` file can be placed in the same directory as the script to set default values.
 * Command-line options will override any values set in the config file.
 *
 * Example miner.conf:
 * node = http://localhost:8000
 * address = PX...
 * cpu = 75
 * threads = 4
 *
 * Options:
 *   -n, --node=<url>        The URL of the PHPCoin node to connect to.
 *   -a, --address=<address> The PHPCoin address to mine rewards to.
 *   -c, --cpu=<percent>     The percentage of CPU to use (0-100). Default: 50.
 *   -t, --threads=<num>     The number of threads to use for mining. Default: 1.
 *   -i, --report-interval=<seconds> The interval in seconds to report mining status. Default: 30.
 *   --flat-log              Enable flat logging for use in environments that do not support carriage returns.
 */

if(php_sapi_name() !== 'cli') exit;

//
// Blockchain & Miner Configuration Constants
//

const BLOCK_TIME = 60;
const BLOCK_TARGET_MUL = 1000;
const MINER_VERSION = "1.5";
const VERSION = "1.6.8";


//
// Class Definitions
//

class Utils {
    public static function validateIp($ip) {
        return filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE | FILTER_FLAG_IPV4);
    }

    public static function url_get($url,$timeout = 30) {
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL,$url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);
        curl_setopt($ch,CURLOPT_SSL_VERIFYHOST, 2);
        curl_setopt($ch,CURLOPT_SSL_VERIFYPEER, 1);
        $result = curl_exec($ch);
        curl_close ($ch);
        return $result;
    }

    public static function url_post($url, $postdata, $timeout=30) {
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL,$url);
        curl_setopt($ch, CURLOPT_POST, 1);
        curl_setopt($ch, CURLOPT_POSTFIELDS, $postdata );
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_TIMEOUT, $timeout);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
        curl_setopt($ch,CURLOPT_SSL_VERIFYHOST, 2);
        curl_setopt($ch,CURLOPT_SSL_VERIFYPEER, 1);
        $result = curl_exec($ch);
        curl_close ($ch);
        return $result;
    }

}


class Crypto {
    public static function calculateHit($block) {
        $hash = hash("sha256", $block->miner . "-" . $block->nonce . "-" . $block->height . "-" . $block->difficulty);
        $hash = hash("sha256", $hash);
        $value = self::gmp_hexdec(substr($hash, 0, 8));
        return gmp_div(gmp_mul(self::gmp_hexdec("ffffffff"), BLOCK_TARGET_MUL) , $value);
    }

    public static function calculateTarget($difficulty, $elapsed) {
        if($elapsed <= 0) {
            return gmp_init(0);
        }
        return gmp_div(gmp_mul($difficulty , BLOCK_TIME), $elapsed);
    }

    public static function calculateNonce($block, $prev_block_date, $elapsed, $chain_id) {
        return hash("sha256", "{$chain_id}{$block->miner}-{$prev_block_date}-{$elapsed}-{$block->argon}");
    }

    public static function calculateArgonHash($address, $prev_block_date, $elapsed, $height) {
        $options = self::hashingOptions($height);
        if($height < 1614556800) { // UPDATE_3_ARGON_HARD
            $options['salt']=substr($address, 0, 16);
        }
        $argon = @password_hash("{$prev_block_date}-{$elapsed}", PASSWORD_ARGON2I, $options);
        if ($argon === false) {
            // Handle hash failure, perhaps log an error or die
            die("Error: password_hash failed.\n");
        }
        return $argon;
    }

    public static function hashingOptions($height=null) {
        if($height < 1614556800) { // UPDATE_3_ARGON_HARD
            return ['memory_cost' => 2048, "time_cost" => 2, "threads" => 1];
        } else {
            return ['memory_cost' => 32768, "time_cost" => 2, "threads" => 1];
        }
    }

    public static function gmp_hexdec($n) {
        $gmp = gmp_init(0);
        $mult = gmp_init(1);
        for ($i=strlen($n)-1;$i>=0;$i--,$mult=gmp_mul($mult, 16)) {
            $gmp = gmp_add($gmp, gmp_mul($mult, hexdec($n[$i])));
        }
        return $gmp;
    }
}


class MinerSetup {
    private $config;
    private $valid = false;

    public function __construct() {
        $this->checkEnvironment();
        $this->loadConfig();
        $this->parseArguments();
        $this->validateConfig();
    }

    private function checkEnvironment() {
        if (version_compare(PHP_VERSION, '7.4', '<')) {
            die("Error: PHP version 7.4 or higher is required.\n");
        }

        $required_extensions = ['curl', 'gmp', 'pcntl'];
        foreach ($required_extensions as $ext) {
            if (!extension_loaded($ext)) {
                die("Error: The required PHP extension '$ext' is not installed or enabled.\n");
            }
        }
    }

    private function loadConfig() {
        // 1. Set default config values
        $this->config = [
            'node' => null,
            'address' => null,
            'cpu' => 50,
            'threads' => 1,
            'report-interval' => 30,
            'flat-log' => false,
            'slip' => 20,
        ];

        // 2. Load config from miner.conf file
        $conf_file = __DIR__."/miner.conf";
        echo "Looking for config file at: " . $conf_file . PHP_EOL;
        if(is_readable($conf_file)) {
            echo "Config file is readable." . PHP_EOL;
            $minerConf = parse_ini_file($conf_file);
            echo "Config file contents: " . print_r($minerConf, true) . PHP_EOL;
            if (empty($minerConf)) {
                echo "Config file is empty or could not be parsed." . PHP_EOL;
            } else {
                foreach($minerConf as $key => $value) {
                    if(array_key_exists($key, $this->config)) {
                        $this->config[$key] = $value;
                        echo "Set config from file: " . $key . " = " . $value . PHP_EOL;
                    }
                }
            }
        } else {
            echo "Config file not found or is not readable." . PHP_EOL;
        }
    }

    private function parseArguments() {
        $options = getopt(
            "n:a:c:t:i:s:", // Short options
            [
                "node:",
                "address:",
                "cpu:",
                "threads:",
                "report-interval:",
                "flat-log",
                "slip:",
            ]
        );
        $this->config['node'] = $options['node'] ?? $options['n'] ?? $this->config['node'];
        $this->config['address'] = $options['address'] ?? $options['a'] ?? $this->config['address'];
        $this->config['cpu'] = $options['cpu'] ?? $options['c'] ?? $this->config['cpu'];
        $this->config['threads'] = $options['threads'] ?? $options['t'] ?? $this->config['threads'];
        $this->config['report-interval'] = $options['report-interval'] ?? $options['i'] ?? $this->config['report-interval'];
        $this->config['slip'] = $options['slip'] ?? $options['s'] ?? $this->config['slip'];
        if(isset($options['flat-log'])) $this->config['flat-log'] = true;
    }

    private function validateConfig() {
        if ($this->config['cpu'] > 100) $this->config['cpu'] = 100;
        $this->config['cpu'] = (int)$this->config['cpu'];
        $this->config['threads'] = (int)$this->config['threads'];

        if(empty($this->config['node']) || empty($this->config['address'])) {
            $filename = basename(__FILE__);
            echo "Usage: php {$filename} --node=<node> --address=<address> [--cpu=<cpu>] [--threads=<threads>] [--report-interval=<seconds>] [--flat-log]".PHP_EOL;
            return;
        }

        // Verify node communication and public key
        $url = $this->config['node'] . "/api.php?q=getPublicKey&address=".$this->config['address'];
        echo "Verifying public key with primary node: " . $url . PHP_EOL;
        $res = Utils::url_get($url);
        if(empty($res)) {
            echo "No response from node".PHP_EOL;
            return;
        }
        $res = json_decode($res, true);
        if(empty($res) || $res['status'] != "ok" || empty($res['data'])) {
            echo "Invalid response from node: ".json_encode($res).PHP_EOL;
            return;
        }

        echo "Network:        ".$res['network'].PHP_EOL;
        $this->valid = true;
    }

    public function isValid() {
        return $this->valid;
    }

    public function getConfig() {
        return $this->config;
    }
}


class Miner {

	private $address;
	private $node;
	private $cpu;
    private $is_forked = false;
    private bool $use_flat_log;
    private $threads;
    private $report_interval;
    private $slip;

	private $is_running = true;

    private $hashing_start_time = 0;
    private $hash_count = 0;
    private $speed = 0;
    private $sleep_time;
    private $attempt_count = 0;
    private $best_hit = 0;

    private $mining_stats;
    private $mining_nodes = [];

	function __construct($config)
	{
		$this->address = $config['address'];
		$this->node = $config['node'];
        $this->cpu = $config['cpu'];
        $this->use_flat_log = $config['flat-log'];
        $this->threads = $config['threads'];
        $this->report_interval = $config['report-interval'];
        $this->slip = $config['slip'];
	}

    /**
     * Forks the miner process to run on multiple threads.
     */
    public function fork() {
        $pids = [];
        $tmp_dir = sys_get_temp_dir() . "/phpcoin-miner-" . uniqid();
        if (!mkdir($tmp_dir)) {
            die("Could not create temporary directory for stats");
        }

        for ($i = 1; $i <= $this->threads; $i++) {
            $pid = pcntl_fork();
            if ($pid == -1) {
                die("Could not fork");
            } else if (!$pid) {
                // This is the child process
                $this->is_forked = true;
                $this->start($tmp_dir);
                exit;
            } else {
                $pids[] = $pid;
            }
        }

        $info = $this->getMiningInfo();
        $height = $info['data']['height'] + 1;
        $this->monitor($pids, $tmp_dir, $height);

        // Cleanup
        array_map('unlink', glob("$tmp_dir/*"));
        rmdir($tmp_dir);
    }

    public function getPeers() {
        $url = $this->node."/api.php?q=getPeers";
        echo "Fetching peer list from primary node: " . $url . PHP_EOL;
        $peers = Utils::url_get($url);
        if(!$peers) {
            echo "Could not fetch peer list. Using primary node only." . PHP_EOL;
            $this->mining_nodes = [$this->node];
            return;
        }
        $peers = json_decode($peers, true);
        if ($peers['status'] != "ok") {
            echo "Could not fetch peer list. Using primary node only." . PHP_EOL;
            $this->mining_nodes = [$this->node];
            return;
        }
        echo "Found " . count($peers['data']) . " potential peers. Verifying mining-enabled nodes..." . PHP_EOL;
        $this->mining_nodes = [$this->node];
        foreach($peers['data'] as $peer) {
            if (!empty($peer['generator']) && !in_array($peer['hostname'], $this->mining_nodes)) {
                $this->mining_nodes[] = $peer['hostname'];
            }
        }
        echo "Verified " . count($this->mining_nodes) . " mining-enabled nodes: " . implode(", ", $this->mining_nodes) . PHP_EOL;
    }

    private function monitor($pids, $tmp_dir, $height) {
        $start_time = time();
        $header_printed = false;
        while (count($pids) > 0) {
            // Check for finished children
            foreach ($pids as $key => $pid) {
                $res = pcntl_waitpid($pid, $status, WNOHANG);
                if ($res == -1 || $res > 0) {
                    unset($pids[$key]);
                }
            }

            if (time() - $start_time > $this->report_interval) {
                $total_hashes = 0;
                $total_submits = 0;
                $total_accepted = 0;
                $total_rejected = 0;
                $total_dropped = 0;
                $total_speed = 0;
                $best_hit = 0;

                $files = glob($tmp_dir . "/*.json");
                foreach($files as $file) {
                    $stats = json_decode(file_get_contents($file), true);
                    if ($stats) {
                        $total_hashes += $stats['hashes'];
                        $total_submits += $stats['submits'];
                        $total_accepted += $stats['accepted'];
                        $total_rejected += $stats['rejected'];
                        $total_dropped += $stats['dropped'];
                        $total_speed += $stats['speed'];
                        if ($stats['best_hit'] > $best_hit) {
                            $best_hit = $stats['best_hit'];
                        }
                    }
                }

                if (!$header_printed) {
                    echo sprintf(
                        "%-6s %-7s %-5s %-8s %-10s %-10s %-10s %-10s %-5s %-5s %-5s %-5s" . PHP_EOL,
                        "PID", "Height", "Elapsed", "Speed", "Hit", "Best", "Slip", "Target", "Submits", "Accepted", "Rejected", "Dropped"
                    );
                    $header_printed = true;
                }

                $lines = 0;
                foreach($files as $file) {
                    $stats = json_decode(file_get_contents($file), true);
                    if ($stats) {
                        echo sprintf(
                            "%-6s %-7s %-5s %-8s %-10s %-10s %-10s %-10s %-5s %-5s %-5s %-5s" . PHP_EOL,
                            $stats['pid'], number_format($stats['height']), $stats['elapsed'], number_format($stats['speed']) . ' H/s', number_format($stats['hit']), number_format($stats['best_hit']), number_format($stats['slip']), number_format($stats['target']),
                            $stats['submits'], $stats['accepted'], $stats['rejected'], $stats['dropped']
                        );
                        $lines++;
                    }
                }

                $start_time = time();
            }

            sleep(1);
        }
        echo PHP_EOL;
    }

    private function removeNode($node) {
        if (($key = array_search($node, $this->mining_nodes)) !== false) {
            unset($this->mining_nodes[$key]);
        }
    }


    /**
     * Starts the main mining loop.
     */
	public function start($tmp_dir = null) {
		$this->mining_stats = [
			'started' => time(), 'hashes' => 0, 'submits' => 0,
			'accepted' => 0, 'rejected' => 0, 'dropped' => 0,
		];
		$this->sleep_time = (100 - $this->cpu) * 5;

		while ($this->is_running) {
			$info = $this->getMiningInfo();
			if (!$this->isValidMiningInfo($info)) {
				sleep(3); // Wait before retrying
				continue;
			}

			$block = $this->initializeNewBlock($info);
			$this->findBlockSolution($block, $info, $tmp_dir);
		}
	}

	private function isValidMiningInfo($info) {
		if ($info === false || !isset($info['data']['generator'], $info['data']['ip'])) {
			return false;
		}
		if (!Utils::validateIp($info['data']['ip'])) {
			return false;
		}
		return true;
	}

	private function initializeNewBlock($info) {
        $block = new stdClass();
		$block->height = $info['data']['height'] + 1;
		$block->difficulty = $info['data']['difficulty'];
		$block->prevBlockId = $info['data']['block'];
        $block->miner = $this->address;
		return $block;
	}

	private function findBlockSolution($block, $info, $tmp_dir = null) {
		$this->attempt_count = 0;
		$this->hashing_start_time = microtime(true);
        $this->best_hit = 0;

		$solution = $this->hashingLoop($block, $info['data']['date'], $info['data']['time'], $info['data']['chain_id'], $tmp_dir);

		if ($solution) {
			$this->submitBlock($solution);
		}
	}

	private function hashingLoop($block, $block_date, $nodeTime, $chain_id, $tmp_dir = null) {
		$offset = $nodeTime - time();
        $last_report_time = 0;
        $future_target = gmp_init(0);

        $this->updateMiningStats($block->height, 0, 0, 0, $future_target, $tmp_dir);

		while (true) {
			$this->attempt_count++;
			if ($this->sleep_time === INF) {
				$this->is_running = false;
				return null;
			}
			usleep($this->sleep_time * 1000);

			$now = time();
			$elapsed = $now - $offset - $block_date;

			if ($elapsed <= 0) {
				continue;
			}

			$hash_time_start = microtime(true);
			$block->argon = Crypto::calculateArgonHash($this->address, $block_date, $elapsed, $block->height);
			$block->nonce = Crypto::calculateNonce($block, $block_date, $elapsed, $chain_id);
			$hit = Crypto::calculateHit($block);
            if ($hit > $this->best_hit) {
                $this->best_hit = $hit;
            }
			$target = Crypto::calculateTarget($block->difficulty, $elapsed);
            $future_target = Crypto::calculateTarget($block->difficulty, $elapsed + $this->slip);

			$this->measureSpeed($hash_time_start);
            if (time() - $last_report_time > $this->report_interval) {
                $this->updateMiningStats($block->height, $elapsed, $hit, $target, $future_target, $tmp_dir);
                $last_report_time = time();
            }

			if ($hit > 0 && $future_target > 0 && $hit > $future_target) {
                $solution_elapsed = $elapsed + $this->slip;
				return [
					'argon' => $block->argon, 'nonce' => $block->nonce, 'height' => $block->height,
					'difficulty' => $block->difficulty, 'date' => $block_date + $solution_elapsed,
					'hit' => gmp_strval($hit), 'target' => gmp_strval($future_target), 'elapsed' => $solution_elapsed,
				];
			}

			if ($this->hasNewBlock($block->prevBlockId)) {
				$this->mining_stats['dropped']++;
				return null;
			}
		}
	}

    private function measureSpeed($hash_time_start) {
        $hash_time_end = microtime(true);
        $this->hashing_start_time += ($hash_time_end - $hash_time_start);
        $this->hash_count++;
        $total_time = $hash_time_end - $this->hashing_start_time;
        if($total_time > 0) {
            $this->speed = round($this->hash_count / $total_time, 2);
        }
    }

	private function hasNewBlock($prev_block_id) {
		// Check for a new block on the network every 10 attempts
		if ($this->attempt_count % 10 == 0) {
			$info = $this->getMiningInfo();
			if ($info !== false && $info['data']['block'] != $prev_block_id) {
				return true;
			}
		}
		return false;
	}

    private function getMiningInfo() {
        return json_decode(Utils::url_get($this->node . "/mine.php?q=info"), true);
    }

	private function submitBlock($solution) {
		$postData = [
			'argon' => $solution['argon'], 'nonce' => $solution['nonce'], 'height' => $solution['height'],
			'difficulty' => $solution['difficulty'], 'address' => $this->address, 'hit' => $solution['hit'],
			'target' => $solution['target'], 'date' => $solution['date'], 'elapsed' => $solution['elapsed'],
			'minerInfo' => 'phpcoin-miner cli ' . VERSION, "version" => VERSION
		];

		$this->mining_stats['submits']++;
        $accepted = false;
        if (is_array($this->mining_nodes) && count($this->mining_nodes) > 0) {
            foreach ($this->mining_nodes as $key => $node) {
                $response = Utils::url_post($node . "/mine.php?q=submitHash&", http_build_query($postData), 5);
                $response_data = json_decode($response, true);
                if (json_last_error() === JSON_ERROR_NONE && isset($response_data['status']) && $response_data['status'] == "ok") {
                    $accepted = true;
                    break;
                } else {
                    if (isset($response_data['response']) && $response_data['response'] == "mining-not-enabled") {
                        $this->removeNode($node);
                    }
                }
            }
        }

        if ($accepted) {
            $this->mining_stats['accepted']++;
        } else {
            $this->mining_stats['rejected']++;
        }

		sleep(3); // Wait before starting next block
        $this->mining_stats['submitted_blocks'][] = [
            "time" => date("r"),
            "node" => $node,
            "height" => $postData['height'],
            "elapsed" => $postData['elapsed'],
            "hashes" => $this->attempt_count,
            "hit" => $postData['hit'],
            "target" => $postData['target'],
            "status" => $accepted ? "accepted" : "rejected",
            "response" => @$response_data['data']
        ];
        file_put_contents(getcwd() . "/miner_stat.json", json_encode($this->mining_stats));
	}

	private function updateMiningStats($height, $elapsed, $hit, $target, $future_target, $tmp_dir = null) {
        $this->mining_stats['hashes']++;
        $this->mining_stats['speed'] = $this->speed;
        $this->mining_stats['best_hit'] = gmp_strval($this->best_hit);
        $this->mining_stats['pid'] = getmypid();
        $this->mining_stats['height'] = $height;
        $this->mining_stats['elapsed'] = $elapsed;
        $this->mining_stats['hit'] = gmp_strval($hit);
        $this->mining_stats['target'] = gmp_strval($target);
        $this->mining_stats['slip'] = gmp_strval($future_target);
        if ($this->is_forked) {
            file_put_contents($tmp_dir . "/" . getmypid() . ".json", json_encode($this->mining_stats));
        } else {
            $status = sprintf(
                "PID:%-6s Height:%-7s Elapsed:%-5s Speed:%-8s Hit:%-10s Best:%-10s Slip:%-10s Target:%-10s Submits:%-5s Accepted:%-5s Rejected:%-5s Dropped:%-5s",
                getmypid(), number_format($height), $elapsed, number_format($this->speed) . ' H/s', number_format(gmp_strval($hit)), number_format(gmp_strval($this->best_hit)), number_format($this->mining_stats['slip']), number_format(gmp_strval($target)),
                $this->mining_stats['submits'], $this->mining_stats['accepted'],
                $this->mining_stats['rejected'], $this->mining_stats['dropped']
            );
            if (!$this->use_flat_log) {
                echo $status . "\r";
            } else {
                echo $status . PHP_EOL;
            }
        }
	}
}


//
// Main Execution Logic
//

$setup = new MinerSetup();
if (!$setup->isValid()) {
    exit(1);
}
$config = $setup->getConfig();

echo "PHPCoin Miner Version ".MINER_VERSION.PHP_EOL;
echo "Mining server:  ".$config['node'].PHP_EOL;
echo "Mining address: ".$config['address'].PHP_EOL;
echo "CPU:            ".$config['cpu'].PHP_EOL;
echo "Threads:        ".$config['threads'].PHP_EOL;
echo "Report Interval:".$config['report-interval']." seconds".PHP_EOL;
echo "Slip:           ".$config['slip']." seconds".PHP_EOL;

$miner = new Miner($config);

$miner->getPeers();

echo "Starting mining loop..." . PHP_EOL;

if($config['threads'] == 1) {
    $miner->start();
} else {
    $miner->fork();
}
